# функции - часть кода, которая мы можем использовать несколько раз (ака переменные)
# print(), input(), int() - тоже функции, но если нам надо что-то дополнительно, мы можем их создать сами
# для каждой функции желательно писать аннотацию - объяснение, что выполняет функция

global A  # глобальная переменная, можем использовать внутри функций и снаружи
A = int(input())  # но изменяется


def summary(b: int) -> int:  # обычная функция, которая возвращает значения типа int
    """ Возвращает сумму числа с глобальной переменной """  # пишем объяснение, что делает наша функция
    return A + b  # return значит, что там, где мы будем использоваться нашу функцию, будет подставляться сумма А и b
# b - внутренняя переменная, уже на этой строке компьютер не будет знать, чему она равна и что это вообще


def change_number(b: int) -> int:  # вторая функция
    """ Возвращает сумму внутренней переменны и функции summary """
    return b + summary(b)  # мы можем использоваться одну функцию в другой


def change_global_number(b: float) -> None:  # Если написать None, то не надо использовать return
    """ Меняет значение глобальнаой переменной """
    global A  # используем глобальную переменную, её надо объявить, чтобы использовать
    A += b  # После этого изменится переменная? Следующая строка поможет это проверить


change_number(5)  # вызываем функции вот так
print(summary(6))  # если мы используем функции с return, то они сами в консоль ничего не выпишут
print(change_number(90))  # в скобках надо использовать параметры, которые мы задали при создании функции


def recursion(a: int, b: int) -> int:  # рекурсия - функция вызывает саму себя
    """ Выводит максимальное число с помощью рекурсии """
    if a == 0 and b == 0:
        return 0  # в рекурсиях return пишут обычно несколько раз, потому что иначе будет бесконечный вызов самой себя

    a -= 1 if a > 0 else 0  # меняем какие-то параметры, типа наша функция делает что-то полезное и подсчитывает
    b -= 1 if b > 0 else 0

    return recursion(a, b) + 1  # функция будет продолжать вызывать себя, пока не сработает другой return


def fibonachi(a: int) -> int:  # рекурсия для задачу про числа Фибоначчи
    """ Возвращает число из порядка Фибоначчи с номером a """
    if a <= 1:  # первые 2 числа в последовательности равны 1
        return 1
    else:
        return fibonachi(a - 1) + fibonachi(a - 2)  # дальше это сумма двух предыдущих чисел


def factorial(a: int) -> int:  # нахождение факториала
    """ Выводит факториал числа """
    if a == 1:
        return 1
    return a * factorial(a - 1)
